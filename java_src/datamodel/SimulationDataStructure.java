package datamodel;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Observable;

import components.Component;

/**
 * The Simulation Data Structure stores a {@link java.util.Map} of
 * {@link components.Component}s as defined by the system model provided.
 * Each component is generated by the {@link Loader} and then added via
 * {@link SimulationDataStructure#addComponent(Component)}.
 * @author Shane Kwon
 * @author Kevin E. Anderson (k3a@uw.edu)
 * @version 2013.07.21
 */
public class SimulationDataStructure extends Observable
{
	/**
	 * A Map of all {@link components.Components} as defined in the system model.
	 */
	private Map<String, Component> component_map = new HashMap<String, Component>();

	/*
	 * NO CONSTRUCTOR NEEDED.  USING JAVA'S IMPLICIT CONSTRUCTOR.
	 */
	
	/**
	 * Adds a reference to the {@link components.Component} to the data structure.
	 * @param the_component The {@link components.Component} whose reference is added to
	 * the data structure.
	 */
	public void addComponent(final Component the_component)
	{
		if (!component_map.containsKey(the_component.getName()))
		{
			component_map.put(the_component.getName(), the_component);
		}
	}
	
	/**
	 * Exposes the {@link SimulationDataStructure#component_map}.
	 * @return A reference to the {@link SimulationDataStructure#component_map}.
	 */
	public Map<String, Component> getCompleteMap()
	{
		return component_map;
	}
	
	/**
	 * Returns a {@link java.util.Collection} of components for iteration.
	 * @return Returns a {@link java.util.Collection of components for iteration.
	 */
	public Collection<Component> getAllComponents() {
		return component_map.values();
	}
	
	/**
	 * Returns an HTML formatted table of all {@link components.Component}'s names, 
	 * types, previous and current values.  For use in displaying in the 
	 * {@link ui.Simulator}.
	 * @return Returns an HTML formatted table of all {@link components.Component}'s 
	 * names, types, previous and current values.  For use in displaying in the 
	 * {@link ui.Simulator}. 
	 */
	@Override
	public String toString()
	{
		
		StringBuilder sb = new StringBuilder();
		sb.append("<HTML><TABLE><TR><TD>Type</TD><TD>Name</TD><TD>PreviousValue</TD><TD>CurrentValue</TD></TR>");
		for (Entry<String, Component> comp : component_map.entrySet())
		{
			sb.append("<TR><TD>");
			switch (comp.getValue().getType())
			{
			case 0:
				sb.append("FLOW");
				break;
			case 1:
				sb.append("STOCK");
				break;
			case 2:
				sb.append("SUBSYSTEM");
				break;
			case 3:
				sb.append("CONTROL");
				break;
			case 4:
				sb.append("SENSOR");
				break;
			case 5:
				sb.append("CLOUD");
				break;
			}
			sb.append("</TD><TD>");
			sb.append(comp.getKey());
			sb.append("</TD><TD align=\"right\">");
			if (Double.isInfinite(comp.getValue().getPreviousValue()))
			{
				sb.append("infinity");
			} else {
				sb.append(String.format("%.5f",comp.getValue().getPreviousValue()));
			}
			
			sb.append("</TD><TD align=\"right\">");
			if (Double.isInfinite(comp.getValue().getCurrentValue()))
			{
				sb.append("infinity");
			} else {
				sb.append(String.format("%.5f",comp.getValue().getCurrentValue()));
			}
			sb.append("</TD></TR>");
	
		}
		sb.append("</TABLE>");
		return sb.toString();
	}
	
	/**
	 * Allows other classes that make changes to the
	 * {@link SimulationDataStructure#component_map} to force the SimlationDataStructure
	 * to be changed.  This allows the {@link ui.Simulator} to update the display when
	 * a value has changed via the {@link MainControl}.
	 */
	public void setChanged(boolean value)
	{
		
		if (value)
		{ 
			setChanged();
		}
		else
		{
			clearChanged();
		}
	}
}
